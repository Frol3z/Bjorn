// This file contains forward pipeline specific code
// for future reference

---- CPP CODE ----

void Renderer::CreateForwardPipeline()
{
    // TODO: improve the way shader path are handled

    PipelineBuilder pipelineBuilder{ *m_device };
    std::vector<PipelineBuilder::ShaderStageInfo> shaderStages{
        {"./shaders/forward.vert.spv", vk::ShaderStageFlagBits::eVertex},
        {"./shaders/forward.frag.spv", vk::ShaderStageFlagBits::eFragment}
    };
    pipelineBuilder.SetShaderStages(shaderStages);
    pipelineBuilder.EnableVertexInput();
    pipelineBuilder.DisableDepthTest();
    pipelineBuilder.EnableBackfaceCulling();
    pipelineBuilder.SetColorBlending(1); // 1 attachment -> swapchain image
        
    std::vector<vk::DescriptorSetLayout> layouts{ m_descriptorSetLayout };
    std::vector<vk::PushConstantRange> ranges{ m_pushConstantRange };
    pipelineBuilder.SetPipelineLayout(layouts, ranges);
        
    pipelineBuilder.SetAttachmentsFormat(std::vector<vk::Format>{ m_swapchain->GetSurfaceFormat().format }, vk::Format::eUndefined); // no depth attachment
        
    auto [pipeline, pipelineLayout] = pipelineBuilder.BuildPipeline();
    m_fwdPipeline = std::move(pipeline);
    m_fwdPipelineLayout = std::move(pipelineLayout);
}

    void Renderer::RecordForwardCommandBuffer(uint32_t imageIndex)
{
    // Reset command buffer
    m_commandBuffers[m_currentFrame].begin({});

    // Transition image layout to color attachment
    TransitionImageLayout(
        m_swapchain->GetImages()[imageIndex],
        m_swapchain->GetSurfaceFormat().format,
        vk::ImageLayout::eUndefined,
        vk::ImageLayout::eColorAttachmentOptimal,
        {},
        vk::AccessFlagBits2::eColorAttachmentWrite,
        vk::PipelineStageFlagBits2::eTopOfPipe,
        vk::PipelineStageFlagBits2::eColorAttachmentOutput
    );

    // Setup color attachment
    vk::ClearValue clearColor = vk::ClearColorValue(0.0f, 0.0f, 0.0f, 1.0f);
    vk::RenderingAttachmentInfo attachmentInfo{
        .imageView = m_swapchain->GetImageViews()[imageIndex],
        .imageLayout = vk::ImageLayout::eColorAttachmentOptimal,
        .loadOp = vk::AttachmentLoadOp::eClear,
        .storeOp = vk::AttachmentStoreOp::eStore,
        .clearValue = clearColor
    };

    // Setup rendering info
    auto swapchainExtent = m_swapchain->GetExtent();
    vk::RenderingInfo renderingInfo = {
        .renderArea = {.offset = { 0, 0 }, .extent = swapchainExtent},
        .layerCount = 1,
        .colorAttachmentCount = 1,
        .pColorAttachments = &attachmentInfo
    };

    // Begin rendering
    m_commandBuffers[m_currentFrame].beginRendering(renderingInfo);

    // Bind the graphic pipeline (the attachment will be bound to the fragment shader output)
    m_commandBuffers[m_currentFrame].bindPipeline(vk::PipelineBindPoint::eGraphics, m_fwdPipeline);

    // Set viewport and scissor size (dynamic rendering)
    m_commandBuffers[m_currentFrame].setViewport(0, vk::Viewport(0.0f, 0.0f, static_cast<float>(swapchainExtent.width), static_cast<float>(swapchainExtent.height), 0.0f, 1.0f));
    m_commandBuffers[m_currentFrame].setScissor(0, vk::Rect2D(vk::Offset2D(0, 0), swapchainExtent));

    // Bind descriptor sets
    m_commandBuffers[m_currentFrame].bindDescriptorSets(
        vk::PipelineBindPoint::eGraphics, m_fwdPipelineLayout, 0,
        *m_descriptorSets[m_currentFrame], nullptr
    );
        
    // Draw all the objects
    std::vector<Object*> objects = m_scene.GetObjects();
    for (uint32_t i = 0; i < objects.size(); i++)
    {
        Object* obj = objects[i];

        // Update object index
        PushConstants pc{ i };
        m_commandBuffers[m_currentFrame].pushConstants(
            *m_fwdPipelineLayout,
            vk::ShaderStageFlagBits::eVertex,
            0,
            vk::ArrayProxy<const PushConstants>(1, &pc)
        );

        // Bind vertex and index buffer
        auto& mesh = obj->GetMesh();
        m_commandBuffers[m_currentFrame].bindVertexBuffers(0, mesh.GetVertexBuffer().GetHandle(), { 0 });
        m_commandBuffers[m_currentFrame].bindIndexBuffer(mesh.GetIndexBuffer().GetHandle(), 0, mesh.GetIndexType());

        // Draw call
        m_commandBuffers[m_currentFrame].drawIndexed(mesh.GetIndexBufferSize(), 1, 0, 0, 0);
    }

    // Draw Dear ImGui
    DrawImGuiFrame(ImGui::GetDrawData());

    // Finish up rendering
    m_commandBuffers[m_currentFrame].endRendering();

    // After rendering, transition the swapchain image to PRESENT_SRC
    TransitionImageLayout(
        m_swapchain->GetImages()[imageIndex],
        m_swapchain->GetSurfaceFormat().format,
        vk::ImageLayout::eColorAttachmentOptimal,
        vk::ImageLayout::ePresentSrcKHR,
        vk::AccessFlagBits2::eColorAttachmentWrite,
        {},
        vk::PipelineStageFlagBits2::eColorAttachmentOutput,
        vk::PipelineStageFlagBits2::eBottomOfPipe
    );

    // Finish recording command onto the buffer
    m_commandBuffers[m_currentFrame].end();
}

---- SHADER CODE ----

// Global uniform buffer
struct GlobalUniformBuffer
{
    float4x4 view;
    float4x4 proj;
    float4x4 invViewProj;
};

[[vk::binding(0)]]
ConstantBuffer<GlobalUniformBuffer> ubo;

// Per-object data
struct ObjectData
{
    float4x4 model;
};

[[vk::binding(1)]]
StructuredBuffer<ObjectData> objectBuffer;

// Push constant used to access the objectBuffer
struct PushConsts
{
    uint objectIndex;
};
[[vk::push_constant]] PushConsts pushConsts;

struct VertexInput
{
    [[vk::location(0)]] float3 position : POSITION;
    [[vk::location(1)]] float3 normal : NORMAL;
};

struct VertexOutput
{
    float4 position : SV_Position;
    float3 normal : NORMAL;
};

VertexOutput main(VertexInput input, uint vertexId : SV_VertexID)
{
    VertexOutput output;
    float4x4 model = objectBuffer[pushConsts.objectIndex].model;
    output.position = mul(ubo.proj, mul(ubo.view, mul(model, float4(input.position, 1.0))));
    output.normal = input.normal;
    return output;
}

----

struct VertexOutput
{
    float4 position : SV_Position;
    float3 normal : NORMAL;
};

// Hardcoded directional light
static const float3 LIGHT_DIR = float3(0.5, -0.5, 0.0);
static const float3 LIGHT_COL = float3(1.0, 1.0, 1.0);

float4 main(VertexOutput inVert) : SV_Target {
    return float4(inVert.normal, 1.0);
}